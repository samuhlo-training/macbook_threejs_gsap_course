<!--
Auto-generated by: https://github.com/pmndrs/gltfjsx (adaptado a Vue/TresJS)

=== CONVERSIÓN DE REACT A VUE CON TRESJS ===

CONCEPTO CLAVE: gltfjsx genera código React, pero TresJS tiene pattern diferente.

En TresJS, useGLTF retorna valores REACTIVOS (refs de Vue):
- state: ref que contiene el GLTF completo incluyendo scene
- nodes: computed con los nodos del modelo  
- materials: computed con los materiales

PATRÓN RECOMENDADO:
En lugar de recrear cada mesh manualmente, se usa <primitive :object="scene" />
para renderizar toda la escena GLTF directamente.
-->

<script setup lang="ts">
import { watch, computed, onMounted } from 'vue'
import { storeToRefs } from 'pinia'
import { useMacbookStore } from '../../store'
import { noChangeParts } from '../../constants/index'
// ===============================================
// IMPORTS DE TRESJS
// ===============================================
import { useGLTF } from '@tresjs/cientos'
import { Color, SRGBColorSpace, TextureLoader, type Mesh, type MeshStandardMaterial } from 'three'

// ===============================================
// PROPS DEL COMPONENTE
// ===============================================
interface Props {
  position?: [number, number, number]
  rotation?: [number, number, number]
  scale?: number | [number, number, number]
}

const props = withDefaults(defineProps<Props>(), {
  position: () => [0, 0, 0],
  rotation: () => [0, 0, 0],
  scale: 1
})

// ===============================================
// PINIA STORE
// ===============================================
const store = useMacbookStore()
const { color } = storeToRefs(store)

// ===============================================
// CARGA DEL MODELO GLTF
// ===============================================
// IMPORTANTE: useGLTF en TresJS NO es async, retorna refs reactivos
// - state: contiene el GLTF completo (scene, parser, animations, etc.)
// - nodes: computed con todos los nodos accesibles por nombre
// - materials: computed con todos los materiales accesibles por nombre
// @ts-ignore
const { state, nodes, materials } = useGLTF('/models/macbook-14-transformed.glb', { draco: true })

// ===============================================
// ROTACIÓN BASE
// ===============================================
// Ajustamos la rotación para ver el MacBook de frente
// - Pequeña inclinación hacia atrás (-0.2) para mostrar bien la pantalla
// - Sin rotación extra en Y y Z por defecto
const combinedRotation = computed(() => [
  -0.1 + props.rotation[0],  // Inclinación sutil hacia atrás
  props.rotation[1],
  props.rotation[2]
] as [number, number, number])

// ===============================================
// APLICAR TEXTURA A LA PANTALLA
// ===============================================
onMounted(() => {
  // Esperamos a que el modelo esté cargado
  watch(
    () => state.value,
    (gltf) => {
      if (!gltf?.scene) return
      
      // Cargamos la textura de pantalla
      const loader = new TextureLoader()
      loader.load('/screen.png', (texture) => {
        texture.colorSpace = SRGBColorSpace
        texture.needsUpdate = true
        
        // Buscamos el mesh de la pantalla (Object_123)
        const screenMesh = gltf.scene.getObjectByName('Object_123') as Mesh
        if (screenMesh && screenMesh.material) {
          // Aplicamos la textura
          (screenMesh.material as any).map = texture
          ;(screenMesh.material as any).needsUpdate = true
        }
      })
    },
    { immediate: true }
  )
})

// ===============================================
// WATCH PARA CAMBIAR COLOR
// ===============================================
// Equivalente a useEffect de React, pero más explícito
watch(
  [color, () => state.value],
  ([newColor, gltf]) => {
    if (!gltf?.scene) return
    
    gltf.scene.traverse((child) => {
      const mesh = child as Mesh
      if (mesh.isMesh) {
        // noChangeParts contiene nombres de partes que NO cambian de color
        // (pantalla, teclado, logo, etc.)
        if (!noChangeParts.includes(mesh.name)) {
          const material = mesh.material as MeshStandardMaterial
          if (material && material.color) {
            material.color = new Color(newColor)
            material.needsUpdate = true
          }
        }
      }
    })
  },
  { immediate: true }
)
</script>

<template>
  <!--
  RENDERIZADO DEL MODELO
  ======================
  
  En TresJS, la forma más sencilla de renderizar un GLTF es usar <primitive>
  con el objeto scene del modelo. Esto renderiza toda la jerarquía 3D.
  
  La diferencia con React/drei:
  - React: Usas JSX para cada <mesh> individualmente
  - TresJS: Usas <primitive :object="scene" /> para todo el modelo
  
  v-if="state" asegura que solo renderizamos cuando el modelo está cargado.
  -->
  <TresGroup 
    v-if="state?.scene"
    :position="props.position"
    :rotation="combinedRotation"
    :scale="props.scale"
  >
    <!--
    <primitive> es un componente especial de TresJS que acepta
    cualquier objeto de Three.js y lo inserta en la escena.
    
    Pasamos el scene del GLTF, que contiene todos los meshes,
    materiales y jerarquía del modelo.
    -->
    <primitive :object="state.scene" />
  </TresGroup>
</template>

<!--
=== COMPARACIÓN FINAL REACT vs VUE ===

REACT (@react-three/drei):
```jsx
const { nodes, materials, scene } = useGLTF('/model.glb')

return (
  <group>
    <mesh geometry={nodes.Part1.geometry} material={materials.Mat1} />
    <mesh geometry={nodes.Part2.geometry} material={materials.Mat2} />
    ...
  </group>
)
```

VUE (TresJS/Cientos):
```vue
const { state } = useGLTF('/model.glb')

<template>
  <TresGroup v-if="state?.scene">
    <primitive :object="state.scene" />
  </TresGroup>
</template>
```

VENTAJAS DE USAR <primitive>:
1. Menos código repetitivo
2. Mantiene la jerarquía original del modelo
3. Animaciones funcionan automáticamente
4. Actualizaciones de materiales se aplican directamente

NOTA: Si necesitas control individual sobre cada mesh,
puedes acceder a nodes.value.NombreMesh y materials.value.NombreMaterial
-->